* Web.sh

  This project aims to form kind of a shell for the web.  It connects
  web-apps via window-messaging and let's you compose them like a
  shell-script.
** Run

   #+BEGIN_SRC sh
     npm install
     npm start

     # Now the browser opens. Open up a js console and execute a script
     # with the following code:
     #
     #   Websh('input | sed?regex=Foo&replace=bar | cat')
   #+END_SRC
** Tests

   #+BEGIN_SRC sh
     npm install
     npm test
   #+END_SRC
** User-Interface

   A script can be executed from a js console using the ~Websh~
   function which accepts the script as a string and returnes a
   promise.
** Shell language

   The shell-language is designed to be lightweight and easy to
   pick-up and learn.  It's heavily inspired by unix shell scripts.
*** Example

    #+BEGIN_SRC sh
      # Pipelines
      https://mypage.com/prompt-input | https://secondpage.com/

      # Parameters
      https://mypage.com/prompt-input?text=Hello%20world
    #+END_SRC
** Program interface

   A scripts executes multiple so-called programs. These programs are
   web-apps that utilize the window messaging API to communicate with
   the system.
*** Execution-flow

    - The program is being loaded in an ~iframe~
    - Then the content from the standard-input is being transmitted to
      the content-window of the iframe using the following command:

      #+BEGIN_SRC js
        iframe.contentWindow.postMessage(["stdin", [] /* Array of input lines */])
      #+END_SRC

      This ~Array of input lines~ is an array filled with data from
      the output that the previous program generated.  If this is the
      first program being executed the ~Array of input lines~ is an
      empty array.
    - The program should then use the input (or ignore if not need)
      and generate output using the ~print~ [[*System%20calls][system-call]]:

      #+BEGIN_SRC js
        window.parent.postMessage(["print", "Sample output" /* The output data */])
      #+END_SRC

      The ~print~ system-call can be multiple times to generate
      multiple "output lines".
    - Once the program finishes it should use the ~exit~ system-call
      to handover the execution back to the system so that the next
      program can be called.
*** System calls

    The system communication is handled by sys-call-like messages with
    the following syntax:

    #+BEGIN_SRC javascript
      ["print", { my: 'message' }]
    #+END_SRC

    - ~print(<chunks>, ...)~

      This command sends output chunks to the system.
    - ~exit(<exitCode>)~

      This command exits the currently running process and hands-over
      an exit code.  A non-zero exit-code means failure and stops the
      execution of the script immediately.
** Missing features / Todo

   - Environment variables (pass shell-url to validate window
     messages)
   - Interactive shell

     This should be implemented as a plugin (See [[*Plugin-system][Plugin-system]]).
** Known issues

   - Pipe characters in the query params to a command aren't handled
     correctly
** Security implications

   - Commands that operate on sensible user-data should use the second
     parameter of ~window.parent.postMessage()~ to avoid sending data
     to malicious targets.
** Thoughts / ideas

*** Plugin-system

    Provide a plugin-system that loads foreign modules via ~import()~.
    The idea comes from offering an IDE for user-authored scripts
    (stored in the localStorage/indexedDB).  These scripts could then
    be executed through the interface that is exposed on the ~window~.

    This plugin-system might even be possible without modification
    since it could be encouraged to directly edit the ~index.html~ of
    the project.  But it should be cleaned up.
